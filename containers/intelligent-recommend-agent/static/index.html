<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Agent Terminal</title>

    <!-- xterm core -->
    <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css" />
    <script src="https://unpkg.com/xterm/lib/xterm.js"></script>
    <!-- fit addon -->
    <script src="https://unpkg.com/xterm-addon-fit/lib/xterm-addon-fit.js"></script>

    <style>
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        background: #000;
        overflow: hidden;          /* ë°”ê¹¥ ìŠ¤í¬ë¡¤ ì œê±° */
      }

      #terminal-container {
        height: 100%;
        width: 100%;
        box-sizing: border-box;    /* padding í¬í•¨ */
      }

      #terminal {
        height: 100%;
        width: 100%;
      }
    </style>
  </head>

  <body>
    <div id="terminal-container">
      <div id="terminal"></div>
    </div>

    <script>
      const term = new Terminal({
        cursorBlink: true,
        fontSize: 14,
        scrollback: 5000,
        theme: { background: "#000000", foreground: "#ffffff" },
      });

      // fit addon
      const fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);

      term.open(document.getElementById("terminal"));
      fitAddon.fit();
      term.focus();

      window.addEventListener("resize", () => {
        fitAddon.fit();
        sendResize();
      });

      // === WebSocket URL ===
      let wsUrl;
      if (location.protocol === "https:") {
        wsUrl = "wss://" + location.host + "/ws";
      } else if (location.protocol === "http:") {
        wsUrl = "ws://" + location.host + "/ws";
      } else {
        wsUrl = "ws://localhost:8000/ws";
      }

      const socket = new WebSocket(wsUrl);

      // === input state ===
      let awaitingInput = false;
      let inputBuffer = "";
      let promptText = "ğŸ˜Š User > ";

      function clearCurrentLine() {
        // ì»¤ì„œë¥¼ ì¤„ ë§¨ ì•ìœ¼ë¡œ ë³´ë‚´ê³ , í•´ë‹¹ ì¤„ ì „ì²´ ì§€ì›€
        term.write("\r\x1b[2K");
      }

      function redrawInputLine() {
        clearCurrentLine();
        term.write(promptText || "ğŸ˜Š User > ");
        if (inputBuffer) term.write(inputBuffer);
      }

      function writeStdout(text) {
        term.write(String(text).replace(/\n/g, "\r\n"));
      }

      function showPrompt(text) {
        promptText = text ?? promptText;
        term.write(promptText);
        awaitingInput = true;
        inputBuffer = "";
      }

      function endInputLine() {
        term.write("\r\n");
        awaitingInput = false;
        inputBuffer = "";
      }

      // Optional: simple controls for future extension
      function handleControl(msg) {
        const action = msg.action;
        if (action === "clear") {
          term.clear();
          return;
        }
        if (action === "newline") {
          term.write("\r\n");
          return;
        }
        if (action === "set_title" && msg.title) {
          document.title = msg.title;
          return;
        }
      }

      function sendResize() {
        if (socket.readyState !== WebSocket.OPEN) return;
        socket.send(JSON.stringify({
          type: "resize",
          cols: term.cols,
          rows: term.rows,
        }));
      }

      term.write("ğŸ”— Connecting to agent...\r\n");

      socket.onopen = () => {
        writeStdout("âœ”ï¸ Connected!\n\n");
        sendResize();
      };

      socket.onmessage = (ev) => {
        // 1) JSON ì´ë²¤íŠ¸ ì²˜ë¦¬
        try {
          const msg = JSON.parse(ev.data);

          switch (msg.type) {
            case "stdout": {
              const out = String(msg.data ?? "").replace(/\n/g, "\r\n");

              if (awaitingInput) {
                // âœ… ì…ë ¥ì¤„ ë³´í˜¸: stdout ì¶œë ¥ ì „ì— ì…ë ¥ì¤„ ì§€ìš°ê³ ,
                // stdout ì¶œë ¥ í›„ ì…ë ¥ì¤„(í”„ë¡¬í”„íŠ¸+ë²„í¼) ë³µì›
                clearCurrentLine();
                term.write(out);

                // stdoutì´ ê°œí–‰ ì—†ì´ ëë‚  ìˆ˜ë„ ìˆìœ¼ë‹ˆ, ì¤„ë°”ê¿ˆ ë³´ì¥
                if (!out.endsWith("\r\n")) term.write("\r\n");

                redrawInputLine();
              } else {
                term.write(out);
              }
              return;
            }

            case "stderr":
              // stderrë„ ì¼ë‹¨ stdoutì²˜ëŸ¼ ì¶œë ¥ (ì›í•˜ë©´ ìƒ‰ ì…íˆëŠ” ì œì–´ ì‹œí€€ìŠ¤ë„ ê°€ëŠ¥)
              writeStdout(msg.data ?? "");
              return;

            case "prompt":
              // promptëŠ” input() í˜¸ì¶œ ì‹œì ì—ë§Œ ì˜¤ë„ë¡ ë°±ì—”ë“œê°€ ë³´ëƒ„
              showPrompt(msg.text ?? "ğŸ˜Š User > ");
              return;

            case "control":
              handleControl(msg);
              return;

            default:
              // ëª¨ë¥´ëŠ” íƒ€ì…ì€ ì•ˆì „í•˜ê²Œ ì¶œë ¥
              writeStdout(ev.data);
              return;
          }
        } catch {
          // 2) í•˜ìœ„í˜¸í™˜: ê¸°ì¡´ì²˜ëŸ¼ plain textê°€ ì˜¤ë©´ ê·¸ëŒ€ë¡œ ì¶œë ¥
          writeStdout(ev.data);
        }
      };

      socket.onerror = (err) => {
        writeStdout("\nâŒ WebSocket error\n\n");
        console.error("WS error", err);
      };

      socket.onclose = () => {
        writeStdout("\nğŸ”Œ Disconnected\n\n");
        awaitingInput = false;
      };

      // === í‚¤ ì…ë ¥ ì²˜ë¦¬: promptê°€ ì˜¨ ë’¤ì—ë§Œ ì…ë ¥ í—ˆìš© ===
      term.onData((data) => {
        if (socket.readyState !== WebSocket.OPEN) return;
        if (!awaitingInput) return;

        if (data === "\r") { // Enter
          // ë°±ì—”ë“œëŠ” ws.receive_text()ë¡œ ë°›ëŠ”ë‹¤ê³  ê°€ì • -> ë¬¸ìì—´ë§Œ ë³´ëƒ„
          socket.send(inputBuffer);
          endInputLine();
          return;
        }

        if (data === "\u007f") { // Backspace
          if (inputBuffer.length > 0) {
            inputBuffer = inputBuffer.slice(0, -1);
            term.write("\b \b");
          }
          return;
        }

        // printable chars only (í™”ì‚´í‘œ ë“± ì œì–´ë¬¸ì ìµœì†Œ ë¬´ì‹œ)
        if (data >= " " && data !== "\x7f") {
          inputBuffer += data;
          term.write(data);
        }
      });
    </script>
  </body>
</html>